import { MongoClient, Collection, Db, ObjectId } from 'mongodb';
import type { MenuItem } from './types';

const MONGODB_URI = process.env.MONGODB_URI;
const MONGODB_DB_NAME = process.env.MONGODB_DB_NAME;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable inside .env.local');
}

if (!MONGODB_DB_NAME) {
    throw new Error('Please define the MONGODB_DB_NAME environment variable inside .env.local');
}

// These are 'cached' in the node process, so we don't have to reconnect on every request.
let cachedClient: MongoClient | null = null;
let cachedDb: Db | null = null;

export async function connectToDatabase() {
  if (cachedClient && cachedDb) {
    return { client: cachedClient, db: cachedDb };
  }

  try {
    const client = await MongoClient.connect(MONGODB_URI, {});
    const db = client.db(MONGODB_DB_NAME);
    
    cachedClient = client;
    cachedDb = db;

    console.log("Successfully connected to MongoDB.");
    return { client, db };
  } catch (error) {
    console.error("Failed to connect to MongoDB:", error);
    throw new Error('Failed to connect to the database. Please check your connection string and credentials.');
  }
}

async function getSiteSettingsCollection(): Promise<Collection<any>> {
    const { db } = await connectToDatabase();
    return db.collection('siteSettings');
}

export async function getMenuItemsCollection(): Promise<Collection<MenuItem>> {
    const { db } = await connectToDatabase();
    return db.collection<MenuItem>('menuItems');
}

// Site Settings
export async function getHeroImage() {
    const collection = await getSiteSettingsCollection();
    const settings = await collection.findOne({ name: 'heroImage' });
    return settings ? settings.value : null;
}

export async function updateHeroImage(imageUrl: string) {
    const collection = await getSiteSettingsCollection();
    return collection.updateOne(
        { name: 'heroImage' },
        { $set: { value: imageUrl } },
        { upsert: true }
    );
}

// About Page Settings
export async function getAboutPageImages() {
    const collection = await getSiteSettingsCollection();
    const imageKeys = ['aboutOurStoryImage', 'aboutCulinaryStoryImage', 'aboutChefLeoAvatar', 'aboutMariaAvatar', 'aboutSofiaAvatar'];
    const settings = await collection.find({ name: { $in: imageKeys } }).toArray();
    const images: { [key: string]: string | null } = {};
    imageKeys.forEach(key => {
        const setting = settings.find(s => s.name === key);
        images[key] = setting ? setting.value : null;
    });
    return images;
}

export async function updateAboutImage(imageKey: string, imageUrl: string) {
    const collection = await getSiteSettingsCollection();
    return collection.updateOne(
        { name: imageKey },
        { $set: { value: imageUrl } },
        { upsert: true }
    );
}


// Menu Item functions
export async function getFeaturedMenuItems() {
    const collection = await getMenuItemsCollection();
    // find returns a cursor, so we need to convert it to an array
    return collection.find({ featured: true }).limit(4).toArray();
}

export async function getAllMenuItems() {
    const collection = await getMenuItemsCollection();
    return collection.find({}).sort({ name: 1 }).toArray();
}

export async function addMenuItem(item: Omit<MenuItem, 'id' | '_id'>) {
    const collection = await getMenuItemsCollection();
    // The `_id` will be automatically generated by MongoDB.
    const itemToAdd: Omit<MenuItem, 'id' | '_id'> = {
        ...item,
        price: item.price,
        // Ensure priceHalf is stored as a number or not at all
        priceHalf: item.priceHalf ? Number(item.priceHalf) : undefined,
    };
    if (itemToAdd.priceHalf === undefined) {
        delete (itemToAdd as Partial<typeof itemToAdd>).priceHalf;
    }
    return collection.insertOne(itemToAdd as MenuItem);
}

export async function updateMenuItem(id: string, itemData: Partial<Omit<MenuItem, 'id' | '_id'>>) {
    const collection = await getMenuItemsCollection();
    
    // Create a mutable copy of itemData
    const dataToUpdate = { ...itemData };

    // Prepare the update operations
    const update: { $set: Partial<any>, $unset?: Partial<any> } = { $set: {} };

    // Coerce priceHalf to a number or handle its absence
    if (dataToUpdate.priceHalf) {
        dataToUpdate.priceHalf = Number(dataToUpdate.priceHalf);
    } else {
        // If priceHalf is not present or falsy, unset it in the database
        if (!update.$unset) update.$unset = {};
        update.$unset.priceHalf = "";
        delete dataToUpdate.priceHalf; // Remove it from the $set operation
    }

    // Set the rest of the data
    update.$set = dataToUpdate;

    // If $unset is empty, remove it from the update object
    if (update.$unset && Object.keys(update.$unset).length === 0) {
        delete update.$unset;
    }
    
    return collection.updateOne({ _id: new ObjectId(id) }, update);
}

export async function deleteMenuItem(id: string) {
    const collection = await getMenuItemsCollection();
    return collection.deleteOne({ _id: new ObjectId(id) });
}
