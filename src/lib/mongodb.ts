import { MongoClient, Collection, Db, ObjectId } from 'mongodb';
import type { MenuItem } from './types';

const MONGODB_URI = process.env.MONGODB_URI;
const MONGODB_DB_NAME = process.env.MONGODB_DB_NAME;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable inside .env.local');
}

if (!MONGODB_DB_NAME) {
    throw new Error('Please define the MONGODB_DB_NAME environment variable inside .env.local');
}

// These are 'cached' in the node process, so we don't have to reconnect on every request.
let cachedClient: MongoClient | null = null;
let cachedDb: Db | null = null;

export async function connectToDatabase() {
  if (cachedClient && cachedDb) {
    return { client: cachedClient, db: cachedDb };
  }

  try {
    const client = await MongoClient.connect(MONGODB_URI, {});
    const db = client.db(MONGODB_DB_NAME);
    
    cachedClient = client;
    cachedDb = db;

    console.log("Successfully connected to MongoDB.");
    return { client, db };
  } catch (error) {
    console.error("Failed to connect to MongoDB:", error);
    throw new Error('Failed to connect to the database. Please check your connection string and credentials.');
  }
}

async function getSiteSettingsCollection(): Promise<Collection<any>> {
    const { db } = await connectToDatabase();
    return db.collection('siteSettings');
}

export async function getMenuItemsCollection(): Promise<Collection<MenuItem>> {
    const { db } = await connectToDatabase();
    return db.collection<MenuItem>('menuItems');
}

// Site Settings
export async function getHeroImage() {
    const collection = await getSiteSettingsCollection();
    const settings = await collection.findOne({ name: 'heroImage' });
    return settings ? settings.value : null;
}

export async function updateHeroImage(imageUrl: string) {
    const collection = await getSiteSettingsCollection();
    return collection.updateOne(
        { name: 'heroImage' },
        { $set: { value: imageUrl } },
        { upsert: true }
    );
}


// Menu Item functions
export async function getFeaturedMenuItems() {
    const collection = await getMenuItemsCollection();
    // find returns a cursor, so we need to convert it to an array
    return collection.find({ featured: true }).limit(4).toArray();
}

export async function getAllMenuItems() {
    const collection = await getMenuItemsCollection();
    return collection.find({}).sort({ name: 1 }).toArray();
}

export async function addMenuItem(item: Omit<MenuItem, 'id' | '_id'>) {
    const collection = await getMenuItemsCollection();
    // The `_id` will be automatically generated by MongoDB.
    const itemToAdd: Omit<MenuItem, 'id' | '_id'> = {
        ...item,
        price: item.price,
        // Ensure priceHalf is stored as a number or not at all
        priceHalf: item.priceHalf ? Number(item.priceHalf) : undefined,
    };
    if (itemToAdd.priceHalf === undefined) {
        delete (itemToAdd as Partial<typeof itemToAdd>).priceHalf;
    }
    return collection.insertOne(itemToAdd as MenuItem);
}

export async function updateMenuItem(id: string, itemData: Partial<Omit<MenuItem, 'id' | '_id'>>) {
    const collection = await getMenuItemsCollection();
    const dataToSet: Partial<Omit<MenuItem, 'id' | '_id'>> = {
        ...itemData,
        price: itemData.price,
        priceHalf: itemData.priceHalf ? Number(itemData.priceHalf) : undefined,
    };

    let updateOperation;

    if (dataToSet.priceHalf) {
        updateOperation = { $set: dataToSet };
    } else {
        // If priceHalf is not provided or is falsy, remove it from the document
        updateOperation = { 
            $set: { ...dataToSet, priceHalf: undefined },
            $unset: { priceHalf: "" }
        };
    }
    
    return collection.updateOne({ _id: new ObjectId(id) }, updateOperation);
}

export async function deleteMenuItem(id: string) {
    const collection = await getMenuItemsCollection();
    return collection.deleteOne({ _id: new ObjectId(id) });
}
